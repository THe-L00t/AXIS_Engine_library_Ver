# AXIS Core 개발 작업 메뉴얼

> **버전**: 1.0
> **최종 수정**: 2025-12-26
> **대상**: AXIS Core 개발에 참여하는 모든 개발자 및 AI 협업 도구

---

## 📋 목차

1. [문서 목적](#문서-목적)
2. [AXIS Core 철학 요약](#axis-core-철학-요약)
3. [Claude Code 사용 시작 가이드](#claude-code-사용-시작-가이드)
4. [단계별 작업 프로세스](#단계별-작업-프로세스)
5. [Claude가 흔히 저지르는 실수](#claude가-흔히-저지르는-실수)
6. [모듈별 체크리스트](#모듈별-체크리스트)
7. [코드 리뷰 기준](#코드-리뷰-기준)
8. [금지 패턴 목록](#금지-패턴-목록)
9. [승인 패턴 목록](#승인-패턴-목록)
10. [트러블슈팅 가이드](#트러블슈팅-가이드)

---

## 문서 목적

이 메뉴얼은 다음을 위해 작성되었습니다:

1. **일관성 유지**: 여러 세션에 걸친 개발에서도 동일한 설계 기준 적용
2. **빠른 온보딩**: 새로운 개발자 또는 AI 세션이 AXIS 철학을 즉시 이해
3. **오류 방지**: 반복되는 설계 실수를 사전에 차단
4. **의사결정 기준**: 모호한 상황에서 판단 기준 제공

---

## AXIS Core 철학 요약

### 핵심 원칙 (Three Axes)

모든 판단은 이 세 질문을 통과해야 합니다:

```
1. 이 설계가 TIME을 더 명확하게 만드는가?
2. 이 설계가 SPACE를 더 정확하게 만드는가?
3. 이 설계가 DATA를 더 정직하게 드러내는가?
```

**통과 기준**: 세 질문 중 최소 하나에 명확한 "YES"
**거부 기준**: 세 질문 모두에 "관계없다" 또는 "불명확"

### axis-core.dll의 정체성

axis-core는:
- ✅ **AXIS 세계의 법칙** (다른 모든 DLL이 따라야 할 규칙)
- ✅ **최소한의 기반** (없으면 안 되는 것만)
- ✅ **5년 뒤에도 설명 가능한 구조**

axis-core는 아님:
- ❌ 게임 엔진
- ❌ 편의 기능 모음
- ❌ 특정 장르 최적화 라이브러리

---

## Claude Code 사용 시작 가이드

### 1단계: 프로젝트 프롬프트 전달

새로운 Claude Code 세션을 시작할 때 **가장 먼저** 다음 프롬프트를 전달하세요:

```markdown
당신은 **AXIS Core 개발 전문 AI 개발자**입니다.

AXIS는 실시간 시스템을 위한 기반 라이브러리이며,
우리는 지금 가장 하위 계층인 **axis-core.dll**을 개발하고 있습니다.

다음 원칙을 **절대적으로** 따르십시오:

1. **성능은 명확성에서 나온다**
2. **혁신은 구조에서 나온다**
3. **범용성은 기초 원리에서 나온다**

모든 설계는 다음 Three Axes를 통과해야 합니다:
- TIME을 더 명확하게?
- SPACE를 더 정확하게?
- DATA를 더 정직하게?

axis-core의 책임:
✅ 메모리 할당/해제, 태깅
✅ 시간 시스템 (프레임, 델타, 고정 스텝)
✅ 로그 시스템
✅ Assert / Fatal Error
✅ 기본 공용 타입 (ID, Handle, Result)

axis-core가 하지 않는 것:
❌ 렌더링, 오디오, 리소스 로딩
❌ OS API 직접 호출 (platform의 책임)
❌ 게임 루프 소유

**DLL 설계 절대 규칙**:
- Public API에는 C ABI 또는 POD 타입만
- STL, 템플릿, 예외, RTTI를 public에 노출 금지
- malloc/free/new/delete 직접 사용 금지
- 모든 메모리는 core allocator 사용
- 생성 함수에는 반드시 파괴 함수 존재
- 숨겨진 전역 상태 금지

코드 제시 전 자가 점검:
1. 다른 DLL이 의존해도 안전한가?
2. 나중에 바꾸기 어렵지 않은가?
3. core에 없으면 안 되는가?

하나라도 "아니오"면 다시 설계하십시오.
```

### 2단계: 작업 메뉴얼 참조 요청

프롬프트 전달 후, 다음을 요청하세요:

```
"작업_메뉴얼.md 파일을 읽고, 특히 '금지 패턴 목록'과 '승인 패턴 목록'을 숙지하십시오."
```

### 3단계: 구체적 작업 지시

이제 구체적인 작업을 시작할 수 있습니다:

```
"Memory 모듈의 public header와 구현을 설계하십시오.
설계 의도와 core 적합성 근거를 함께 제시하십시오."
```

---

## 단계별 작업 프로세스

### Phase 1: 설계 단계

**입력**: 구현할 모듈/기능 명세
**출력**: 설계 문서 + API 초안

#### 체크리스트
- [ ] Three Axes 질문에 답변 작성
- [ ] Public API surface 정의 (C ABI 준수)
- [ ] 메모리 소유권 명확화
- [ ] 초기화/종료 흐름 정의
- [ ] 의존성 목록 작성
- [ ] "왜 core에 속하는가?" 근거 작성

#### 예시 출력 형식

```markdown
## Memory 모듈 설계

### Three Axes 검증
- **TIME**: 메모리 할당은 프레임 경계와 무관하므로 N/A
- **SPACE**: ✅ 메모리는 공간의 직접적 표현
- **DATA**: ✅ 모든 데이터는 메모리에 존재

### Public API
```cpp
// axis_memory.h
typedef struct AxisAllocator AxisAllocator;

AXIS_API AxisAllocator* Axis_CreateAllocator(const char* name, size_t reserve_size);
AXIS_API void Axis_DestroyAllocator(AxisAllocator* allocator);
AXIS_API void* Axis_Alloc(AxisAllocator* allocator, size_t size, const char* tag);
AXIS_API void Axis_Free(AxisAllocator* allocator, void* ptr);
```

### 설계 의도
- 태그 기반 메모리 추적 가능
- 전역 malloc 대체 가능
- Platform-agnostic

### core 적합성 근거
다른 모든 DLL이 메모리 할당을 필요로 하므로,
core가 이를 제공하지 않으면 각 DLL이 독자적으로 구현하게 되어
일관성과 추적 가능성이 사라짐.
```

---

### Phase 2: 구현 단계

**입력**: 승인된 설계
**출력**: 실제 코드 (.h + .cpp)

#### 체크리스트
- [ ] Public header는 순수 C 호환
- [ ] 구현은 C++ 사용 가능 (내부만)
- [ ] 모든 API에 명확한 주석
- [ ] 에러 처리 명시적
- [ ] 메모리 누수 없음
- [ ] 초기화 안 된 변수 없음

#### 금지 사항
```cpp
// ❌ Public header에서 금지
#include <vector>
#include <string>
template<typename T> void Foo();
class AxisAllocator { ... };  // class 대신 struct + opaque pointer
void Bar() throw(std::exception);
```

```cpp
// ❌ 구현에서 금지
void* ptr = malloc(100);  // core allocator 써야 함
static bool g_initialized;  // 제어 불가능한 전역 상태
new MyObject();  // new/delete 직접 사용
```

---

### Phase 3: 검증 단계

**입력**: 구현된 코드
**출력**: 검증 보고서 + 수정 사항

#### 자가 검증 질문

1. **ABI 안정성**
   - Public header를 C 컴파일러로 컴파일 가능한가?
   - 구조체 크기가 컴파일러마다 달라지지 않는가?

2. **메모리 안전성**
   - 모든 할당에 대응하는 해제가 있는가?
   - 댕글링 포인터 가능성은 없는가?

3. **스레드 안전성**
   - 전역 상태 접근이 안전한가?
   - 문서화되지 않은 가정은 없는가?

4. **확장 가능성**
   - 새 기능 추가 시 기존 API 깨지지 않는가?
   - 버전 업그레이드 경로가 명확한가?

---

## Claude가 흔히 저지르는 실수

### 🚫 실수 1: "엔진스러운" 추상화

#### 잘못된 예시
```cpp
// ❌ core에 게임 개념이 들어감
AXIS_API void Axis_UpdateGameObject(AxisGameObject* obj, float deltaTime);
```

#### 올바른 예시
```cpp
// ✅ core는 개념을 제공하지 않음
// GameObject는 상위 레이어(axis-entity 등)의 책임
```

**원인**: "엔진 = GameObject 시스템"이라는 고정관념
**해결**: core는 개념이 아니라 **법칙**만 제공

---

### 🚫 실수 2: STL을 public에 노출

#### 잘못된 예시
```cpp
// ❌ Public header
#include <vector>
AXIS_API std::vector<int> Axis_GetAllocations();
```

#### 올바른 예시
```cpp
// ✅ C-compatible array
AXIS_API int Axis_GetAllocations(int* out_array, int max_count);
```

**원인**: C++ 편의성에 익숙
**해결**: Public = C ABI, 구현 = C++ OK

---

### 🚫 실수 3: 가짜 확장 포인트 만들기

#### 잘못된 예시
```cpp
// ❌ 사용되지 않는 미래 대비 추상화
typedef struct AxisAllocatorVTable {
    void* (*alloc)(size_t);
    void (*free)(void*);
    void (*defragment)(void);  // 아직 필요 없음
    void (*compress)(void);    // 아직 필요 없음
    void (*reserved1)(void);   // 미래를 위한 예약
    void (*reserved2)(void);
} AxisAllocatorVTable;
```

#### 올바른 예시
```cpp
// ✅ 지금 필요한 것만
typedef struct AxisAllocatorVTable {
    void* (*alloc)(size_t);
    void (*free)(void*);
} AxisAllocatorVTable;
```

**원인**: "확장성 = 미리 빈 자리 만들기"라는 오해
**해결**: 확장성은 **구조의 명확성**에서 나옴

---

### 🚫 실수 4: 암묵적 초기화

#### 잘못된 예시
```cpp
// ❌ 처음 호출 시 자동 초기화
void* Axis_Alloc(size_t size) {
    static bool initialized = false;
    if (!initialized) {
        InitializeMemorySystem();
        initialized = true;
    }
    // ...
}
```

#### 올바른 예시
```cpp
// ✅ 명시적 초기화 필수
AXIS_API void Axis_InitializeCore(const AxisCoreConfig* config);
AXIS_API void Axis_ShutdownCore();

void* Axis_Alloc(size_t size) {
    AXIS_ASSERT(g_core_initialized);  // 명시적 체크
    // ...
}
```

**원인**: "편의성 = 자동화"라는 착각
**해결**: 명시성 > 편의성

---

### 🚫 실수 5: 에러 처리를 예외에 의존

#### 잘못된 예시
```cpp
// ❌ 예외 던지기
void Axis_LoadConfig(const char* path) {
    if (!FileExists(path)) {
        throw std::runtime_error("File not found");
    }
}
```

#### 올바른 예시
```cpp
// ✅ 에러 코드 반환
typedef enum AxisResult {
    AXIS_OK = 0,
    AXIS_ERROR_FILE_NOT_FOUND = 1,
    AXIS_ERROR_INVALID_PARAMETER = 2,
} AxisResult;

AXIS_API AxisResult Axis_LoadConfig(const char* path);
```

**원인**: C++ 표준 관행 적용
**해결**: C ABI는 예외를 지원하지 않음

---

### 🚫 실수 6: 과도한 템플릿 사용 (내부 구현에서도)

#### 잘못된 예시
```cpp
// ❌ 불필요한 템플릿 남발
template<typename T, typename Allocator, typename Deleter, int MaxSize>
class AxisSmartPointer {
    // 실제로는 단순 ref counting만 필요
};
```

#### 올바른 예시
```cpp
// ✅ 단순하고 명확
struct AxisRefCounted {
    int ref_count;
    void (*deleter)(void*);
};

void Axis_AddRef(AxisRefCounted* obj);
void Axis_Release(AxisRefCounted* obj);
```

**원인**: "C++ = 템플릿"이라는 고정관념
**해결**: 템플릿은 꼭 필요할 때만

---

### 🚫 실수 7: 문서 없는 가정

#### 잘못된 예시
```cpp
// ❌ 암묵적 요구사항
AXIS_API void Axis_SetThreadName(const char* name);
// 내부적으로 name이 정적 메모리여야 한다는 가정
```

#### 올바른 예시
```cpp
// ✅ 명시적 문서
/**
 * Sets the current thread's name for debugging.
 *
 * @param name Thread name. Must remain valid for the thread's lifetime.
 *             The string is NOT copied internally.
 * @note This function is not thread-safe.
 */
AXIS_API void Axis_SetThreadName(const char* name);
```

**원인**: 코드만으로 충분하다는 착각
**해결**: 모든 가정은 문서화

---

### 🚫 실수 8: Platform 코드를 core에 직접 작성

#### 잘못된 예시
```cpp
// ❌ core에서 직접 OS API 호출
#ifdef _WIN32
#include <windows.h>
void* Axis_AllocImpl(size_t size) {
    return VirtualAlloc(...);
}
#elif __linux__
#include <sys/mman.h>
void* Axis_AllocImpl(size_size) {
    return mmap(...);
}
#endif
```

#### 올바른 예시
```cpp
// ✅ core는 인터페이스만 정의
// axis_memory.h
typedef struct AxisOSMemory {
    void* (*reserve)(size_t size);
    void (*commit)(void* ptr, size_t size);
    void (*release)(void* ptr, size_t size);
} AxisOSMemory;

AXIS_API void Axis_SetOSMemoryInterface(const AxisOSMemory* os_mem);

// 실제 구현은 axis-platform.dll에서
```

**원인**: "메모리 = OS 기능"이라는 직관
**해결**: core는 추상, platform은 구현

---

## 모듈별 체크리스트

### Memory 모듈

설계 시:
- [ ] OS 메모리 인터페이스 분리 (platform의 책임)
- [ ] 태그 기반 추적 가능 구조
- [ ] 프레임 얼로케이터 개념 포함
- [ ] 메모리 통계 수집 가능

구현 시:
- [ ] Public API는 C 호환
- [ ] 할당/해제 쌍 존재
- [ ] 메모리 정렬 명시적 처리
- [ ] 스레드 안전성 문서화

검증 시:
- [ ] 메모리 누수 테스트
- [ ] 이중 해제 감지
- [ ] 태그별 통계 정확성
- [ ] 경계 오버런 감지

---

### Time 모듈

설계 시:
- [ ] 고해상도 시간 원천 추상화
- [ ] 프레임 시간 계산 구조
- [ ] 고정 스텝 지원 가능 구조
- [ ] 시간 스케일 개념 포함 여부 판단

구현 시:
- [ ] Platform time source 주입 가능
- [ ] Delta time 계산 정확성
- [ ] 시간 역행 처리
- [ ] 부동소수점 오차 누적 방지

검증 시:
- [ ] 시간 정확도 (마이크로초 단위)
- [ ] 긴 실행 시간에서 오차 누적 확인
- [ ] 시스템 시간 변경 시 동작

---

### Log 모듈

설계 시:
- [ ] 로그 레벨 정의 (Fatal, Error, Warn, Info, Debug, Trace)
- [ ] Platform-independent sink 인터페이스
- [ ] 포맷 문자열 안전성
- [ ] 디버그/릴리즈 동일 구조

구현 시:
- [ ] 스레드 안전 출력
- [ ] 버퍼 오버플로우 방지
- [ ] Sink 등록/해제 메커니즘
- [ ] 성능 영향 최소화

검증 시:
- [ ] 멀티스레드 로그 테스트
- [ ] 긴 문자열 처리
- [ ] Sink 없을 때 크래시 없음
- [ ] 릴리즈 빌드에서 성능

---

### Assert / Fatal 모듈

설계 시:
- [ ] Assert vs Fatal 구분 명확화
- [ ] 커스텀 핸들러 등록 가능
- [ ] 디버그 빌드 전용 vs 항상 활성
- [ ] 스택 트레이스 포함 여부

구현 시:
- [ ] 매크로 vs 함수 선택
- [ ] 파일/라인/메시지 포함
- [ ] 무한 재귀 방지
- [ ] 릴리즈 빌드 처리

검증 시:
- [ ] Assert 발생 시 동작
- [ ] Fatal error 시 정리 작업
- [ ] 핸들러 체인 동작
- [ ] 릴리즈 빌드 크기 영향

---

## 코드 리뷰 기준

### Level 1: 즉시 거부 (Reject Immediately)

다음 중 하나라도 발견되면 **즉시 거부**하고 재작성 요구:

```cpp
// 1. Public header에 STL 노출
#include <vector>  // ❌
std::string Axis_GetName();  // ❌

// 2. Public header에 템플릿
template<typename T>  // ❌
AXIS_API void Axis_Process();

// 3. Public header에 예외
void Axis_Load() throw(std::exception);  // ❌

// 4. malloc/free/new/delete 직접 사용
void* ptr = malloc(100);  // ❌
MyObject* obj = new MyObject();  // ❌

// 5. 파괴 함수 없는 생성 함수
AXIS_API AxisObject* Axis_CreateObject();  // ❌ Destroy가 없음

// 6. 제어 불가능한 전역 상태
static Config g_config;  // ❌ 초기화 시점 불명확
```

---

### Level 2: 설계 재검토 (Redesign Required)

다음은 기능하지만 **설계 결함**이 있음:

```cpp
// 1. 불명확한 소유권
AXIS_API const char* Axis_GetErrorMessage();  // ❌ 누가 free?

// 2. 암묵적 초기화
void SomeFunction() {
    if (!s_initialized) Init();  // ❌ 명시적이어야 함
}

// 3. 사용되지 않는 확장 포인트
struct Foo {
    void* reserved[10];  // ❌ 가짜 확장성
};

// 4. 문서화되지 않은 가정
AXIS_API void Axis_SetName(const char* name);  // ❌ 복사? 참조?
```

---

### Level 3: 개선 권장 (Improvement Suggested)

기능하고 설계도 괜찮지만 **더 나아질 수 있음**:

```cpp
// 1. 불충분한 에러 처리
AXIS_API void Axis_Process();  // ⚠️ 실패 가능성 표현 안 됨
// 개선: AXIS_API AxisResult Axis_Process();

// 2. 매직 넘버
#define MAX_ALLOCATORS 64  // ⚠️ 근거 불명확
// 개선: 설정 가능하게 또는 문서화

// 3. 불명확한 네이밍
AXIS_API void Axis_Update();  // ⚠️ 무엇을 Update?
// 개선: Axis_UpdateTimeSystem()

// 4. 누락된 const
AXIS_API void Axis_Print(char* message);  // ⚠️ const char*
```

---

### Level 4: 승인 (Approved)

다음은 **좋은 설계**:

```cpp
// 1. 명확한 소유권
AXIS_API char* Axis_AllocateString(const char* src);  // 호출자가 free
AXIS_API void Axis_FreeString(char* str);

// 2. 명시적 초기화
AXIS_API void Axis_InitializeCore(const AxisCoreConfig* config);
AXIS_API void Axis_ShutdownCore();

// 3. 에러 처리 명확
AXIS_API AxisResult Axis_LoadFile(const char* path, void** out_data);

// 4. 문서화된 계약
/**
 * Allocates memory from the specified allocator.
 * @param allocator Must not be NULL.
 * @param size Must be > 0.
 * @param tag Optional tag for tracking (can be NULL).
 * @return Allocated pointer, or NULL if allocation failed.
 * @note Caller must free with Axis_Free().
 */
AXIS_API void* Axis_Alloc(AxisAllocator* allocator, size_t size, const char* tag);
```

---

## 금지 패턴 목록

### 절대 금지 (Never Allowed)

| 패턴 | 이유 | 대안 |
|------|------|------|
| `malloc` / `free` | 추적 불가능 | `Axis_Alloc` / `Axis_Free` |
| `new` / `delete` | ABI 불안정 | Placement new + manual dtor |
| Public header에 `std::` | ABI 깨짐 | C-compatible types |
| Public header에 `template` | ABI 없음 | 함수 포인터 또는 매크로 |
| Public header에 `class` | ABI 불안정 | `struct` + opaque pointer |
| 예외 던지기 (public) | C ABI 비호환 | Error code 반환 |
| RTTI (`dynamic_cast`) | 런타임 비용 | Manual type tagging |
| 전역 생성자 | 초기화 순서 문제 | Explicit init function |
| 싱글톤 패턴 | 테스트 불가능 | Dependency injection |
| `#define` 매크로 (public) | 네임스페이스 오염 | `AXIS_` prefix 필수 |

---

### 조건부 금지 (Context-Dependent)

| 패턴 | 허용 조건 | 금지 조건 |
|------|-----------|-----------|
| Static 변수 | 내부 구현, 초기화 명확 | Public API, 숨겨진 상태 |
| 템플릿 | 내부 구현 (.cpp) | Public header (.h) |
| STL | 내부 구현 | Public header |
| Virtual 함수 | 내부 추상화 | Public interface |
| `auto` keyword | 명확한 타입 | 타입 추론 어려운 경우 |

---

## 승인 패턴 목록

### 강력히 권장 (Highly Recommended)

```cpp
// 1. Opaque Pointer 패턴
// Public header
typedef struct AxisAllocator AxisAllocator;  // Forward declaration
AXIS_API AxisAllocator* Axis_CreateAllocator(...);

// Implementation
struct AxisAllocator {
    // 내부 구현은 public header에 노출 안 됨
    void* internal_data;
    AxisAllocatorVTable* vtable;
};

// 2. Init/Shutdown 쌍
AXIS_API void Axis_InitializeSubsystem(const Config* config);
AXIS_API void Axis_ShutdownSubsystem();

// 3. Create/Destroy 쌍
AXIS_API Handle Axis_CreateResource(...);
AXIS_API void Axis_DestroyResource(Handle handle);

// 4. Result 반환
typedef enum AxisResult {
    AXIS_OK = 0,
    AXIS_ERROR_INVALID_PARAMETER,
    AXIS_ERROR_OUT_OF_MEMORY,
} AxisResult;

AXIS_API AxisResult Axis_DoSomething(...);

// 5. Out 매개변수로 복잡한 반환
AXIS_API AxisResult Axis_GetStats(AxisMemoryStats* out_stats);

// 6. 명시적 크기 제한
AXIS_API int Axis_GetNames(char** out_names, int max_count);
```

---

### 좋은 관행 (Good Practices)

```cpp
// 1. 버전 정보 노출
#define AXIS_VERSION_MAJOR 1
#define AXIS_VERSION_MINOR 0
#define AXIS_VERSION_PATCH 0

AXIS_API int Axis_GetVersion();  // Returns encoded version

// 2. Config 구조체로 확장성 확보
typedef struct AxisCoreConfig {
    size_t memory_reserve_size;
    AxisLogLevel log_level;
    void* user_data;  // 미래 확장
} AxisCoreConfig;

// 3. 콜백은 함수 포인터 + 사용자 데이터
typedef void (*AxisLogCallback)(AxisLogLevel level, const char* message, void* user_data);
AXIS_API void Axis_SetLogCallback(AxisLogCallback callback, void* user_data);

// 4. Boolean은 명확한 이름
AXIS_API int Axis_IsInitialized();  // 0 = false, non-zero = true

// 5. 상수는 enum 또는 #define
typedef enum AxisMemoryTag {
    AXIS_MEMORY_TAG_GENERAL = 0,
    AXIS_MEMORY_TAG_RENDERING = 1,
} AxisMemoryTag;
```

---

## 트러블슈팅 가이드

### 문제 1: "이 기능이 core에 속하는지 불명확함"

**진단 절차**:
1. Three Axes 질문에 답변 작성
2. "이것이 없으면 다른 DLL이 개발 불가능한가?" 질문
3. "이것이 AXIS의 법칙인가, 편의 기능인가?" 질문

**해결**:
- 법칙 → core에 포함
- 편의 기능 → 상위 레이어로 이동
- 불명확 → 일단 제외, 필요 시 추가

---

### 문제 2: "Public API가 너무 제한적"

**증상**:
- C ABI 제약으로 인한 불편함
- 타입 안전성 부족
- 표현력 제한

**해결**:
```cpp
// ❌ 잘못된 해결: STL 노출
AXIS_API std::vector<int> Axis_GetData();

// ✅ 올바른 해결: C++ wrapper 별도 제공
// C API (core)
AXIS_API int Axis_GetData(int* out_array, int max_count);

// C++ wrapper (선택적, header-only)
// axis_memory.hpp
namespace axis {
    inline std::vector<int> GetData() {
        std::vector<int> result(256);
        int count = Axis_GetData(result.data(), 256);
        result.resize(count);
        return result;
    }
}
```

---

### 문제 3: "메모리 추적이 너무 복잡함"

**증상**:
- 모든 할당에 태그 전달이 번거로움
- 내부 구현에서도 allocator 전달 필요

**해결**:
```cpp
// ✅ 계층적 allocator 구조
AXIS_API AxisAllocator* Axis_CreateChildAllocator(
    AxisAllocator* parent,
    const char* name
);

// 사용
AxisAllocator* render_alloc = Axis_CreateChildAllocator(core_alloc, "Rendering");
void* data = Axis_Alloc(render_alloc, 1024, NULL);  // 태그는 "Rendering"으로 자동 추적
```

---

### 문제 4: "Platform 분리가 불명확함"

**기준**:
- **Core**: "무엇을", "왜" (추상화)
- **Platform**: "어떻게" (구현)

**예시**:
```cpp
// Core의 책임: 시간의 개념 정의
typedef struct AxisTime {
    uint64_t nanoseconds;
} AxisTime;

AXIS_API AxisTime Axis_GetCurrentTime();  // 인터페이스만

// Platform의 책임: 실제 OS 시간 획득
// Windows platform
AxisTime Axis_GetCurrentTime() {
    LARGE_INTEGER counter;
    QueryPerformanceCounter(&counter);
    // ...
}

// Linux platform
AxisTime Axis_GetCurrentTime() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    // ...
}
```

---

### 문제 5: "확장 가능하게 만들고 싶은데 방법 모르겠음"

**잘못된 방향**:
```cpp
// ❌ 빈 확장 포인트
struct Foo {
    void* reserved[16];
};
```

**올바른 방향**:
```cpp
// ✅ 명확한 인터페이스 + 버전 관리
typedef struct AxisAllocatorVTable_v1 {
    uint32_t version;  // = 1
    void* (*alloc)(size_t);
    void (*free)(void*);
} AxisAllocatorVTable_v1;

typedef struct AxisAllocatorVTable_v2 {
    uint32_t version;  // = 2
    void* (*alloc)(size_t);
    void (*free)(void*);
    void (*defragment)();  // 새 기능
} AxisAllocatorVTable_v2;

// 사용 시 버전 체크
if (vtable->version >= 2) {
    AxisAllocatorVTable_v2* v2 = (AxisAllocatorVTable_v2*)vtable;
    v2->defragment();
}
```

---

## 부록: 빠른 참조 카드

### 설계 의사결정 트리

```
새 기능 추가 요청
    ↓
[Q1] Three Axes 중 하나에 명확히 "YES"인가?
    NO → 거부
    YES ↓
[Q2] 이것 없이 다른 DLL 개발 불가능한가?
    NO → 상위 레이어로 이동
    YES ↓
[Q3] Public API로 노출 가능한가? (C ABI)
    NO → 재설계
    YES ↓
[Q4] 메모리/시간/로그와 무관하게 작동하는가?
    YES → Platform 또는 별도 DLL
    NO ↓
승인 → core에 포함
```

---

### Public API 체크리스트 (1분 점검)

```
[ ] C 컴파일러로 컴파일 가능
[ ] struct 크기 고정 (포인터는 opaque)
[ ] 모든 함수에 AXIS_API
[ ] 모든 타입에 Axis prefix
[ ] malloc/new 미사용
[ ] 생성/파괴 쌍 존재
[ ] 에러 처리 명시적
[ ] 소유권 문서화
```

---

## 문서 이력

| 버전 | 날짜 | 변경 사항 |
|------|------|-----------|
| 1.0 | 2025-12-26 | 초기 작성 |

---

## 라이선스 및 기여

이 문서는 AXIS 프로젝트의 일부입니다.
문서 개선 제안은 프로젝트 리드에게 문의하십시오.

---

**마지막 조언**:

이 메뉴얼은 **억압이 아니라 해방**을 위한 것입니다.

제약이 많아 보이지만, 실제로는:
- 불필요한 고민을 줄여주고
- 명확한 판단 기준을 제공하며
- 일관된 품질을 보장합니다.

**"이거 해도 되나?"** 싶을 때,
이 메뉴얼을 펼치십시오.

대부분의 답은 이미 여기 있습니다.
